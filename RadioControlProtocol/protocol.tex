\documentclass{report}

\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{siunitx}
\usepackage{float}
\usepackage{xparse}

\setlength\parindent{0pt}

\title{RadioControl-Protocol}
\author{Paul Nykiel}

\begin{document}

\maketitle
\tableofcontents

\pagebreak

\chapter{Introduction}
  Fast and extensible communication over various serial-interfaces. Primarily
  designed for radio-controlled models, mesh capable.

\section{Example Application}
\subsection{Trainer}
Transmitter $\to$ Transmitter $\to$ Plane
\subsection{Long Range}
  Long Range: Multiple Transmitters, Drone as Repeater. TCP for Transmitters.

\chapter{Protocol}
  The protocol is designed for serial interfaces, the data is binary encoded to
  optimize for slow connections. The protocol consists of packages, one package
  contains all channel data.

  \section{Timing}
    A new package should be transmitted by the sender at a rate of 50Hz (every
    20ms) which is the rate a normal Servo or ESC gets signals at. The minimum
    time between each package should be 10ms to allow every device to parse the
    data.

  \section{Mesh behavior}
    The sender of a message is the one deciding wheter a package should be mesh
    package or a normal package. A normal package gets tranmitted by the sender
    and every device in reach receives the message and can use the data.


    In a mesh application the sender needs to set the mesh flag.
    Furthermore the sender needs to specify a routing length which sets the maximum amount of
    nodes the package passes by.
    Each recipient resends the message and decreases the routing length value by one
    until the routing length value reaches the value zero. To avoid that the same
    packages passes multiple nodes the same time every node
    needs to keep track of the packages it forwarded, this is done by having a
    sufficient sized ring buffer which saves the last UIDs of the packages forwarded,
    the size is determined by the amount of packages per time, in a normal application
    the size should be between 64 and 128.

    In complex applications where two nodes can be connected via multiple
    paths it is not guaranteed for the communication to work, in general this should be
    avoided.

  \section{Package structure}
    Every package consists of four major parts:
    \begin{enumerate}
      \item Header
      \item Configuration
      \item Data
      \item Footer
    \end{enumerate}

  \subsection{Header}
    The header consists of three bytes:
    \begin{enumerate}
      \item Start byte
      \item Unique-ID
      \item Transmitter-ID
    \end{enumerate}

    \subsubsection{Start byte}
    The start byte is one byte which is always ${C9}_\text{HEX}$.

    \subsubsection{Unique-ID}
     The unique-ID is generated by the initial sender. It is used to identify a
     message, especially in a mesh-application.

    \paragraph{Algorithm for generation of the UID}
     The easiest way of generation is having a counter shared by all devices,
     every time a device receives or transmits a package the counter gets
     incremented. If the upper limit of a byte (255) is reached the counter
     overflows. This implementation guarantees maximum time between reoccurring
     UIDs.

    \subsubsection{Transmitter-ID}
     A persistent ID which should be unique to the transmitter. Optimally it
     should be easily configurable by the user, for example via a configuration
     file, a settings menu or DIP-Switches on the module.

  \subsection{Configuration}
    The configuration consists of at least one byte.

    \subsubsection{First configuration byte (general)}
     The first byte consists of the following bits:
     \begin{itemize}
       \item Bit 0-2: Resolution
       \item Bit 3-5: Channel count
       \item Bit 6: Error
       \item Bit 7: Following
     \end{itemize}

    \subsubsection{Resolution}
     Three bytes containing the resolution of each channel transmitted, possible
     values are listened in table~\ref{fig:resValues}.
     \begin{figure}
         \centering
         \begin{tabular}{rrr}
           \toprule
           Value & Resolution (Steps) &	Bit per Channel \\
           \midrule
           $000_2$ & 32 & 5 \\
           $001_2$ & 64 & 6 \\
           $010_2$ & 128 & 7 \\
           $011_2$ & 256 & 8 \\
           $100_2$ & 512 & 9 \\
           $101_2$ & 1024 & 10 \\
           $110_2$ & 2048 & 11\\
           $111_2$ & 4096 & 12 \\
           \bottomrule
         \end{tabular}
         \caption{Possible resolution values}
         \label{fig:resValues}
     \end{figure}


    \subsubsection{Channel count}
     Three bytes containing the amount of channels used, possible values are
     listed in table~\ref{fig:channelValues}.

     \begin{figure}[H]
         \centering
         \begin{tabular}{rrr}
           \toprule
           Value & Channels \\
           \midrule
           $000_2$ & 1 \\
           $001_2$ & 2 \\
           $010_2$ & 4 \\
           $011_2$ & 8 \\
           $100_2$ & 16 \\
           $101_2$ & 32 \\
           $110_2$ & 64 \\
           $111_2$ & 256 \\
           \bottomrule
         \end{tabular}
         \caption{Possible channel count values}
         \label{fig:channelValues}
     \end{figure}

    \subsubsection{Error}
     If a device registers an error (checksum, timeout during package
     transmission) this flag is set for the next 4 packages send by this device.

    \subsubsection{Following}
     This byte is a flag whether the following byte is still a configuration
     byte and not a data byte.

    \subsubsection{Second configuration byte (mesh)}
     The second byte consists of the following bits:
     \begin{itemize}
         \item Bit 0: Mesh-Message
         \item Bit 1-4: Routing Length
         \item Bit 5-6: unused
         \item Bit 7: Following
     \end{itemize}

    \subsubsection{Mesh-Message}
     A flag whether the message is intended as a Mesh-Message, this flag
     defaults to false if the following flag in the first configuration byte is
     not set.

    \subsubsection{Routing Length}
     A number counting the amounts of nodes this message has been passed by. The
     initial sender sets the value and every node decrements the value. If the
     value reaches zero, the package doesn't get forwarded.

    \subsubsection{Following}
     This byte is a flag whether the following byte is still a configuration
     byte and not a data byte. At the moment this byte needs to be false.

  \subsection{Data}
    The size (in bytes) of the data section is determined by
    the resolution and the channel count:
    \begin{equation}
        \text{size} = \left\lceil{\frac{\text{resolution} \cdot \text{Channel count}}{8}} \right\rceil
    \end{equation}

   The data is just queued together so the first r (with r being the channel
   resolution) bits are the first channel, bits r+1 to r*2 are the second
   until the last channel. If there are unused bits left at the end they are
   ignored.

  \subsection{Footer}
    The footer consists of two bytes Checksum End byte

    \subsubsection{Checksum}
     For the checksum think of the transmitted data as list starting with the
     unique-ID and ending with the last data byte. The checksum is once
     calculated by the sender and once by the recipient to verify the data is
     still correct.

    \subsubsection{Algorithm}
     The checksum is similar to a normal parity bit. To calculate the checksum
     take your list and count for every bit how often it is 1 across all bytes,
     if it is odd the corresponding bit in the checksum is 1 else 0.
     So the $n$-th bit of your checksum byte is the parity bit of all $n$-th
     bits of your list.

    \subsubsection{End byte}
     The end byte is one byte which is always $93_\text{HEX}$.

\end{document}
